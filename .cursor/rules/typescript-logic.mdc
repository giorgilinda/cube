---
description: Combined standards for TS/JS logic, Arrow Functions, and Guard Clauses
globs: **/*.{ts,js,tsx,jsx}
---
# TypeScript & JavaScript Logic Doctrine

## 1. Function Definition: Arrow First
- **Standard**: Always use **Arrow Functions** for functions, hooks, and components.
- **Exception**: Only use traditional `function` declarations if you specifically need `this` context or hoisting (rare in modern frontend).
- ✅ **Good**: `const calculateTotal = (items: Item[]): number => { ... }`
- ❌ **Bad**: `function calculateTotal(items) { ... }`

## 2. The Guard Clause Pattern (Fail Fast)
- **Philosophy**: "Un-nest" code by flipping logic. Handle edge cases at the top and leave the "Happy Path" at the bottom without nesting.
- **The Rule**: Max nesting depth is **2**. If it goes deeper, you MUST refactor using Guard Clauses.
- **Implementation**: 
  - Instead of `if (condition) { /* code */ }`, use `if (!condition) return;`.
  - Check for `null`, `undefined`, or invalid states immediately.



## 3. Best Practices & Safety
- **Immutability**: Use `const` by default. Use `map`, `filter`, and `reduce` over `for` loops.
- **Null Safety**: Use Optional Chaining (`?.`) and Nullish Coalescing (`??`).
- **Async/Await**: Always use `async/await` over raw `.then()`. Wrap top-level logic in `try/catch`.
- **Boolean Naming**: Prefix booleans with `is`, `has`, `should`, or `can`.

## 4. Comprehensive Example
```typescript
const processOrder = async (order: Order | null): Promise<string> => {
  // 1. Guard Clauses (Edge cases first)
  if (!order) return "No order provided";
  if (order.status !== 'pending') return "Order already processed";
  if (!order.items.length) throw new Error("Empty order");

  // 2. The "Happy Path" (Clean and flat)
  const total = order.items.reduce((acc, item) => acc + item.price, 0);
  await saveOrder(order, total);
  
  return "Order processed successfully";
};